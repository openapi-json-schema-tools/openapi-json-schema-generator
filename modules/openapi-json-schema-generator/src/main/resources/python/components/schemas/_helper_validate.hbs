{{#if types}}
    {{#gt types.size 1}}
        {{#each types}}
            {{#eq this "object"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/_helper_validate_args }}
                {{#if ../mapOutputJsonPathPiece}}
) -> {{../mapOutputJsonPathPiece.camelCase}}: ...
                {{else}}
) -> schemas.immutabledict[str, schemas.INPUT_TYPES_ALL_INCL_SCHEMA]: ...
                {{/if}}
            {{else}}
                {{#eq this "boolean"}}
{{> components/schemas/_helper_validate_bool_overload includeNonEnum=true enumInfo=../enumInfo }}
                {{else}}
                    {{#eq this "null"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/_helper_validate_args }}
) -> None: ...
                    {{else}}
                        {{#eq this "string"}}
{{> components/schemas/_helper_validate_str_overload includeNonEnum=true enumInfo=../enumInfo }}
                        {{else}}
                            {{#eq this "number"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/_helper_validate_args }}
) -> typing.Union[float, int]: ...
                            {{else}}
                                {{#eq this "integer"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/_helper_validate_args }}
) -> {{#if ../enumInfo}}typing_extensions.Literal[
        {{#each ../enumInfo.typeToValues.integer}}
    {{value}},
        {{/each}}
]{{else}}int{{/if}}: ...
                                {{else}}
                                    {{#eq this "array"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/_helper_validate_args }}
) -> {{#if ../arrayOutputJsonPathPiece}}{{../arrayOutputJsonPathPiece.camelCase}}{{else}}typing.Tuple[schemas.OUTPUT_BASE_TYPES]{{/if}}: ...
                                    {{else}}
                                        {{#eq this "object"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/_helper_validate_args }}
) -> {{#if ../mapOutputJsonPathPiece}}{{../mapOutputJsonPathPiece.camelCase}}{{else}}schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]{{/if}}: ...
                                        {{/eq}}
                                    {{/eq}}
                                {{/eq}}
                            {{/eq}}
                        {{/eq}}
                    {{/eq}}
                {{/eq}}
            {{/eq}}
        {{/each}}
    {{else}}
        {{! only one type }}
{{> components/schemas/_helper_validate_str_overload includeNonEnum=false }}
{{> components/schemas/_helper_validate_bool_overload includeNonEnum=false }}
        {{#if enumInfo}}
            {{#if enumInfo.typeToValues.integer}}
                {{#each enumInfo.typeToValues.integer}}
@typing.overload
@classmethod
def validate(
    cls,
    arg: typing_extensions.Literal[{{value}}],
    configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
) -> typing_extensions.Literal[{{value}}]: ...
                {{/each}}
@typing.overload
@classmethod
def validate(
    cls,
    arg: int,
    configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
) -> typing_extensions.Literal[{{#each enumInfo.typeToValues.integer}}{{value}},{{/each}}]: ...
            {{/if}}
        {{/if}}
        {{! end of enum overloads }}
    {{/gt}}
@classmethod
def validate(
    {{#eq types.size 1}}
        {{#if enumInfo}}
            {{#eq type "integer"}}
    cls,
    arg,
    configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
            {{else}}
                {{#eq type "boolean"}}
    cls,
    arg,
    configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
                {{else}}
                    {{#eq type "string"}}
    cls,
    arg,
    configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
                    {{else}}
        {{#each types}}
    {{> components/schemas/_helper_validate_args }}
        {{/each}}
                    {{/eq}}
                {{/eq}}
            {{/eq}}
        {{else}}
        {{#each types}}
    {{> components/schemas/_helper_validate_args }}
        {{/each}}
        {{/if}}
    {{else}}
    cls,
    arg,
    configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    {{/eq}}
    {{#eq types.size 1}}
        {{#each types}}
            {{#eq this "object"}}
                {{#if mapOutputJsonPathPiece}}
) -> {{mapOutputJsonPathPiece.camelCase}}:
                {{else}}
) -> schemas.immutabledict[str, schemas.INPUT_TYPES_ALL_INCL_SCHEMA]:
                {{/if}}
            {{else}}
                {{#eq this "boolean"}}
) -> {{#if ../enumInfo}}typing_extensions.Literal[
        {{#each ../enumInfo.typeToValues.boolean}}
    {{#if value}}True{{else}}False{{/if}},
        {{/each}}
]{{else}}bool{{/if}}:
                {{else}}
                    {{#eq this "null"}}
) -> None:
                    {{else}}
                        {{#eq this "string"}}
) -> {{#if ../enumInfo}}typing_extensions.Literal[
        {{#each ../enumInfo.typeToValues.string}}
    "{{{value}}}",
        {{/each}}
]{{else}}str{{/if}}:
                        {{else}}
                            {{#eq this "number"}}
) -> typing.Union[float, int]:
                            {{else}}
                                {{#eq this "integer"}}
) -> {{#if ../enumInfo}}typing_extensions.Literal[
        {{#each ../enumInfo.typeToValues.integer}}
    {{value}},
        {{/each}}
]{{else}}int{{/if}}:
                                {{else}}
                                    {{#eq this "array"}}
                                        {{#if arrayOutputJsonPathPiece}}
) -> {{arrayOutputJsonPathPiece.camelCase}}:
                                        {{else}}
) -> typing.Tuple[schemas.INPUT_TYPES_ALL_INCL_SCHEMA]:
                                        {{/if}}
                                    {{/eq}}
                                {{/eq}}
                            {{/eq}}
                        {{/eq}}
                    {{/eq}}
                {{/eq}}
            {{/eq}}
        {{/each}}
    {{else}}
):
    {{/eq}}
    {{#if enumInfo}}
    validated_arg = super().validate(
        arg,
        configuration=configuration,
    )
        {{#eq types.size 1}}
            {{#eq type "string"}}
    return typing.cast(typing_extensions.Literal[
                {{#each enumInfo.typeToValues.string}}
            "{{{value}}}",
                {{/each}}
        ],
        validated_arg
    )
            {{else}}
                {{#eq type "integer"}}
    return typing.cast(typing_extensions.Literal[
                {{#each enumInfo.typeToValues.integer}}
            {{value}},
                {{/each}}
        ],
        validated_arg
    )
                {{else}}
                    {{#eq type "boolean"}}
    return typing.cast(typing_extensions.Literal[
                {{#each enumInfo.typeToValues.boolean}}
            {{#if value}}True{{else}}False{{/if}},
                {{/each}}
        ],
        validated_arg
    )
                    {{else}}
    return validated_arg
                    {{/eq}}
                {{/eq}}
            {{/eq}}
        {{else}}
            {{! no multiple enum types }}
    return validated_arg
        {{/eq}}
    {{else}}
        {{! no enumInfo }}
    return super().validate(
        arg,
        configuration=configuration,
    )
    {{/if}}
{{/if}}
